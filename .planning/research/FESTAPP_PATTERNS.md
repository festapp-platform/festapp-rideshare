# Festapp Codebase Patterns — What to Reuse

**Source:** `/Users/miakh/source/festapp` (Flutter + Supabase)
**Purpose:** Patterns vetted for adoption in festapp-rideshare (TypeScript monorepo)

## ADOPT — Use These

### 1. Database Timestamps (auto-update trigger)
Every table gets `created_at` and `updated_at` with a shared trigger:
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Applied per table:
CREATE TRIGGER update_rides_updated_at
    BEFORE UPDATE ON rides
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```
**Why good:** Prevents bugs, zero client-side logic needed.

### 2. SECURITY DEFINER + Permission Check Functions
RPC functions use `SECURITY DEFINER` with explicit permission checks:
```sql
CREATE OR REPLACE FUNCTION book_ride(p_ride_id BIGINT, p_seats INT)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Always check permissions first
    PERFORM check_user_can_book(p_ride_id);
    -- ... business logic ...
END;
$$;
```
Reusable permission checks like `check_is_manager_on_unit()` are extracted into separate functions.
**Why good:** Defense-in-depth. Even if RLS is misconfigured, functions enforce access control.

### 3. RLS Policies with Subquery Auth
```sql
CREATE POLICY "Users can view their own bookings"
ON bookings FOR SELECT TO authenticated
USING (
    passenger_id = auth.uid()
    OR EXISTS (
        SELECT 1 FROM rides WHERE rides.id = bookings.ride_id AND rides.driver_id = auth.uid()
    )
);
```
**Why good:** Clear, testable, named descriptively.

### 4. Edge Function Shared Utilities
```
supabase/functions/
├── _shared/           # Reusable across all functions
│   ├── auth.ts        # AuthError class, authorization helpers
│   ├── emailClient.ts # Email sending (AWS SES in our case)
│   └── supabaseUtil.ts # Admin + user-scoped client creation
├── send-email/
├── notify/
└── ...
```
**Why good:** DRY, consistent error handling, testable.

### 5. Custom AuthError Class
```typescript
export class AuthError extends Error {
  status: number;
  constructor(message: string, status: number) {
    super(message);
    this.name = "AuthError";
    this.status = status;
  }
}
```
**Why good:** Maps directly to HTTP response codes. Clean error boundaries.

### 6. Batch Processing with Time Awareness
Edge functions respect the 60s timeout:
```typescript
const startTime = Date.now();
const timeLimit = 60000;
const safetyMargin = 10000;
while (tasks.length > 0 && Date.now() - startTime < timeLimit - safetyMargin) {
    // process next task
}
```
**Why good:** Prevents edge function timeouts on large batches.

### 7. i18n Flat JSON with {placeholder} Syntax
```json
{
  "Sign in": "Přihlásit se",
  "E-mail with credentials was sent to: {email}.": "E-mail s přihlašovacími údaji byl odeslán na: {email}.",
  "Your ride is in {hours} hours": "Vaše jízda je za {hours} hodin"
}
```
**Why good:** Simple, human-readable keys, works with i18next interpolation.

### 8. Naming Conventions
- Tables: `snake_case` plural (`rides`, `bookings`, `user_info`)
- Columns: `snake_case` (`created_at`, `departure_time`, `is_hidden`)
- Foreign keys: `{referenced_table}_id` or just `{entity}` (`driver_id`, `ride_id`)
- RPC functions: verb-first (`book_ride`, `cancel_booking`, `get_user_rides`)
- RPC params: `p_` prefix (`p_ride_id`, `p_seats`)
- Constraints: `{table}_{column}_fkey`

### 9. BIGINT IDs + UUID for Users
- Regular tables: `BIGINT GENERATED BY DEFAULT AS IDENTITY`
- User-related: `UUID REFERENCES auth.users(id)`

### 10. Check Constraints for State Machines
```sql
CHECK (status IN ('upcoming', 'in_progress', 'completed', 'cancelled'))
```
**Why good:** Database enforces valid states. No invalid data possible.

### 11. Dual Supabase Clients in Edge Functions
```typescript
const supabaseAdmin = createClient(url, serviceRoleKey);     // Bypasses RLS
const userClient = createClient(url, anonKey, { headers });   // Respects RLS
```
**Why good:** Admin for system operations, user-scoped for permission-sensitive queries.

### 12. Strategic JSONB Columns
Used for semi-structured data that varies per entity:
```sql
booking_rules JSONB,  -- Flexible rules per ride type
features JSONB,       -- Feature flags per entity
data JSONB            -- Extensible metadata
```
**Why good:** Avoids schema changes for flexible fields. But document the shape in code.

## ADAPT — Good Idea, Modify for Our Stack

### 1. Translation String Classes → TypeScript Modules
Festapp uses Dart classes (`FormStrings.get formTitle`). For TypeScript:
```typescript
// packages/shared/src/i18n/keys.ts (type-safe wrapper)
export const keys = {
  rides: {
    postTitle: 'rides.postTitle',
    searchPlaceholder: 'rides.searchPlaceholder',
  },
} as const;
```
Use `i18next` with namespace-based JSON files instead of flat keys for 150+ requirements.

### 2. Soft Delete → deleted_at Timestamp
Festapp uses `is_hidden BOOLEAN`. Better for audit:
```sql
deleted_at TIMESTAMP WITH TIME ZONE NULL  -- NULL = active, set = soft-deleted
```
Add to RLS policies: `AND deleted_at IS NULL`.

### 3. Database Table Schema Wrapper → Zod Schemas
Festapp defines column names in Dart classes (`Tb.occasions.title`). For TypeScript, use Zod:
```typescript
// packages/shared/src/schemas/ride.ts
export const RideSchema = z.object({
  id: z.number(),
  driver_id: z.string().uuid(),
  origin: z.string(),
  destination: z.string(),
  departure_at: z.string().datetime(),
  seats: z.number().int().min(1).max(8),
  status: z.enum(['upcoming', 'in_progress', 'completed', 'cancelled']),
});
```
Shared between web, mobile, and Edge Functions.

### 4. Migration Naming → Supabase CLI Standard
Festapp mixes version numbers (`0.16.5.sql`) with timestamps (`20260113165000_*.sql`). Use only:
```
supabase/migrations/YYYYMMDDHHMMSS_description.sql
```

## SKIP — Don't Use These

| Pattern | Why Skip |
|---------|----------|
| Gender-prefixed i18n keys (`MYou have been signed in.`) | Fragile hack. Use i18next pluralization/context |
| Default organization = 1 | Implicit tenant is dangerous. Always require explicit context |
| Inconsistent NULL handling on timestamps | Always use `NOT NULL DEFAULT now()` |
| Nodemailer in Deno Edge Functions | Unstable. Use AWS SES SDK directly |
| Manual upsert (`IF EXISTS... UPDATE... ELSE INSERT`) | Use `INSERT ... ON CONFLICT DO UPDATE` |
| String-based template handler keys | Use TypeScript discriminated unions or enums |

## Implementation Notes

- **Reference repo:** `/Users/miakh/source/festapp` for concrete examples during phase planning
- **Key files to reference:**
  - `supabase/migrations/` — SQL patterns and schema evolution
  - `supabase/functions/_shared/` — Edge Function utilities
  - `assets/translations/` — i18n file structure
  - `lib/data_services/auth_service.dart` — Auth flow (adapt for Expo)
