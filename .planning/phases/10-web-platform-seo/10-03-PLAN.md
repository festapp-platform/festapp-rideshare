---
phase: 10-web-platform-seo
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/(app)/app-nav.tsx
  - apps/web/app/globals.css
  - supabase/migrations/043_api_rate_limiting.sql
  - supabase/functions/_shared/rate-limit.ts
  - supabase/functions/ai-assistant/index.ts
  - supabase/functions/compute-route/index.ts
  - supabase/functions/send-notification/index.ts
autonomous: true

must_haves:
  truths:
    - "Web app navigation is fully responsive across mobile, tablet, and desktop breakpoints"
    - "API rate limiting protects public endpoints from abuse"
    - "Edge Functions enforce per-IP and per-user request limits"
  artifacts:
    - path: "supabase/migrations/043_api_rate_limiting.sql"
      provides: "Rate limiting tracking table and cleanup function"
      contains: "rate_limit"
    - path: "supabase/functions/_shared/rate-limit.ts"
      provides: "Reusable rate limiting middleware for Edge Functions"
      contains: "checkRateLimit"
  key_links:
    - from: "supabase/functions/ai-assistant/index.ts"
      to: "supabase/functions/_shared/rate-limit.ts"
      via: "import checkRateLimit"
      pattern: "checkRateLimit"
    - from: "supabase/functions/compute-route/index.ts"
      to: "supabase/functions/_shared/rate-limit.ts"
      via: "import checkRateLimit"
      pattern: "checkRateLimit"
---

<objective>
Audit and fix responsive design across breakpoints, and add API rate limiting to all public Edge Function endpoints.

Purpose: WEB-04 (responsive design), WEB-09 (API rate limiting). Ensure the web app works seamlessly on phones, tablets, and desktops. Protect expensive endpoints (AI, route computation, notifications) from abuse.

Output: Responsive design fixes, rate limiting infrastructure, rate-limited Edge Functions.
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@apps/web/app/(app)/app-nav.tsx
@supabase/functions/ai-assistant/index.ts
@supabase/functions/compute-route/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Responsive design audit and tablet breakpoint fixes</name>
  <files>
    apps/web/app/(app)/app-nav.tsx
    apps/web/app/globals.css
    apps/web/app/(app)/components/ride-card.tsx
    apps/web/app/(app)/components/search-form.tsx
    apps/web/app/(app)/components/ride-detail.tsx
  </files>
  <action>
1. Audit and fix `apps/web/app/(app)/app-nav.tsx`:
   - Current: hidden on mobile (`hidden md:flex`), bottom tabs on mobile
   - Add tablet breakpoint: on `md` (768px+) show collapsible sidebar with icons only, on `lg` (1024px+) show full sidebar with labels
   - Mobile bottom nav: ensure touch targets are at least 44x44px
   - Add `aria-label` to all nav items for accessibility
   - Desktop sidebar: add `w-16 lg:w-64` transition for collapsed/expanded state
   - Sidebar labels: `hidden lg:block` for text, icons always visible

2. Audit `apps/web/app/globals.css`:
   - Add tablet-specific utilities if needed
   - Ensure `safe-area-inset-bottom` is applied to bottom nav for notched phones:
     ```css
     .pb-safe { padding-bottom: env(safe-area-inset-bottom, 0px); }
     ```
   - Add `viewport-fit=cover` support class

3. Audit `apps/web/app/(app)/components/ride-card.tsx`:
   - Ensure card layout works at all breakpoints
   - On mobile: full-width card with stacked info
   - On tablet: 2-column grid
   - On desktop: cards within max-w-4xl container (already set in layout)
   - Add `sm:grid-cols-2` to search results grid if not already present

4. Audit `apps/web/app/(app)/components/search-form.tsx`:
   - Ensure form inputs stack on mobile, align horizontally on tablet+
   - Date picker and autocomplete fields should be full-width on mobile
   - Add responsive grid: `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4`

5. Audit `apps/web/app/(app)/components/ride-detail.tsx`:
   - Ensure ride detail layout is readable on all screen sizes
   - Map should be full-width on mobile, constrained on desktop
   - Booking button should be sticky bottom on mobile: `sticky bottom-0 bg-white p-4 border-t md:static md:border-0 md:p-0`

For ALL files: only make changes where the current layout is broken or suboptimal. If a component is already responsive, leave it alone. Focus on:
- Touch target sizes (min 44px)
- Safe area insets for mobile
- Tablet sidebar collapse
- Readable text sizes across breakpoints
  </action>
  <verify>
    - `grep "safe-area" apps/web/app/globals.css` shows safe area support
    - `grep "aria-label" apps/web/app/(app)/app-nav.tsx` shows accessibility labels
    - `pnpm --filter @festapp/web build` succeeds
  </verify>
  <done>
    Navigation collapses to icons on tablet and expands on desktop. Bottom nav has safe area padding for notched phones. All touch targets meet 44px minimum. Search form and ride cards adapt to mobile/tablet/desktop grid layouts. Ride detail booking button is sticky on mobile.
  </done>
</task>

<task type="auto">
  <name>Task 2: API rate limiting on Edge Functions</name>
  <files>
    supabase/migrations/043_api_rate_limiting.sql
    supabase/functions/_shared/rate-limit.ts
    supabase/functions/ai-assistant/index.ts
    supabase/functions/compute-route/index.ts
    supabase/functions/send-notification/index.ts
    supabase/functions/check-route-alerts/index.ts
  </files>
  <action>
1. Create `supabase/migrations/043_api_rate_limiting.sql`:
   - Create table `public.api_rate_limits`:
     ```sql
     CREATE TABLE public.api_rate_limits (
       id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
       identifier TEXT NOT NULL,     -- IP address or user ID
       endpoint TEXT NOT NULL,       -- function name
       request_count INT NOT NULL DEFAULT 1,
       window_start TIMESTAMPTZ NOT NULL DEFAULT NOW(),
       UNIQUE(identifier, endpoint, window_start)
     );
     ```
   - Create index on `(identifier, endpoint, window_start)`
   - Create cleanup function called by cron to delete rows older than 1 hour:
     ```sql
     CREATE OR REPLACE FUNCTION clean_rate_limits()
     RETURNS void AS $$
     BEGIN
       DELETE FROM public.api_rate_limits WHERE window_start < NOW() - INTERVAL '1 hour';
     END;
     $$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';
     ```
   - Schedule cron: `SELECT cron.schedule('clean-rate-limits', '*/15 * * * *', 'SELECT clean_rate_limits()')`
   - RLS: enable RLS, no policies (only accessed via SECURITY DEFINER functions)

2. Create `supabase/functions/_shared/rate-limit.ts`:
   - Export `checkRateLimit(req: Request, endpoint: string, limits: { maxRequests: number, windowSeconds: number })`:
     - Extract identifier: prefer `x-forwarded-for` header, fall back to `Authorization` header hash, fall back to "anonymous"
     - Use admin Supabase client (service_role) to query api_rate_limits
     - Count requests in current window (floor to windowSeconds boundary)
     - If count >= maxRequests: return `{ limited: true, retryAfter: secondsRemaining }`
     - If count < maxRequests: increment counter (upsert), return `{ limited: false }`
   - Export `rateLimitResponse(retryAfter: number)`: returns `new Response(JSON.stringify({ error: 'Too many requests' }), { status: 429, headers: { 'Retry-After': String(retryAfter), ...corsHeaders } })`

3. Add rate limiting to `supabase/functions/ai-assistant/index.ts`:
   - Import `checkRateLimit` and `rateLimitResponse` from `../_shared/rate-limit.ts`
   - At the top of the handler (after CORS preflight check): call `checkRateLimit(req, 'ai-assistant', { maxRequests: 20, windowSeconds: 60 })`
   - If limited, return `rateLimitResponse(retryAfter)`
   - This is the most expensive endpoint (Claude API calls), so 20 req/min is appropriate

4. Add rate limiting to `supabase/functions/compute-route/index.ts`:
   - Rate limit: 30 requests per 60 seconds per identifier
   - Same pattern: check at top of handler, return 429 if limited

5. Add rate limiting to `supabase/functions/send-notification/index.ts`:
   - Rate limit: 50 requests per 60 seconds per identifier
   - This is server-to-server only (service_role auth), but still rate limit for safety

6. Add rate limiting to `supabase/functions/check-route-alerts/index.ts`:
   - Rate limit: 10 requests per 60 seconds per identifier
   - This is trigger-invoked, limit protects against rapid ride creation

Rate limit values summary:
- ai-assistant: 20/min (expensive, user-facing)
- compute-route: 30/min (Google API quota protection)
- send-notification: 50/min (internal, high-volume)
- check-route-alerts: 10/min (trigger-invoked)
  </action>
  <verify>
    - `cat supabase/migrations/043_api_rate_limiting.sql | grep "api_rate_limits"` shows table creation
    - `grep "checkRateLimit" supabase/functions/_shared/rate-limit.ts` returns match
    - `grep "checkRateLimit" supabase/functions/ai-assistant/index.ts` returns match
    - `grep "429" supabase/functions/_shared/rate-limit.ts` returns match
  </verify>
  <done>
    Rate limiting table tracks request counts per identifier/endpoint/window. Shared rate-limit utility provides reusable checking and 429 response. All 4 Edge Functions enforce per-identifier request limits. Cron job cleans expired rate limit entries every 15 minutes.
  </done>
</task>

</tasks>

<verification>
- `pnpm --filter @festapp/web build` succeeds
- All Edge Functions import and use rate limiting
- Rate limit table migration is valid SQL
- Navigation is responsive across mobile, tablet, desktop
- Safe area insets applied for notched phones
</verification>

<success_criteria>
- Navigation has 3 responsive states: mobile bottom tabs, tablet collapsed sidebar, desktop expanded sidebar
- All touch targets >= 44px on mobile
- Rate limiting returns 429 with Retry-After header when exceeded
- Rate limit entries are cleaned up via cron every 15 minutes
- `pnpm --filter @festapp/web build` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/10-web-platform-seo/10-03-SUMMARY.md`
</output>
