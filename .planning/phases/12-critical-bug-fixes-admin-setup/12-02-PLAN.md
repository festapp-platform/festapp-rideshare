---
phase: 12-critical-bug-fixes-admin-setup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/(app)/components/ride-form.tsx
autonomous: true
requirements: [BUG-01]

must_haves:
  truths:
    - "User types a natural language ride description and sees origin, destination, date, time, and price pre-filled in the ride form"
    - "AI-set values persist when navigating between wizard steps"
    - "Geocoding converts AI address strings to PlaceResult objects with lat/lng"
  artifacts:
    - path: "apps/web/app/(app)/components/ride-form.tsx"
      provides: "forwardGeocode helper, updated handleAiPrompt with geocoding + setOrigin/setDestination, shouldUnregister:false"
      contains: "forwardGeocode"
    - path: "apps/web/app/(app)/components/ride-form.tsx"
      provides: "shouldUnregister: false on useForm config"
      contains: "shouldUnregister"
  key_links:
    - from: "handleAiPrompt in ride-form.tsx"
      to: "Mapy.cz /v1/geocode API"
      via: "forwardGeocode helper converting address strings to PlaceResult"
      pattern: "api\\.mapy\\.cz/v1/geocode"
    - from: "handleAiPrompt in ride-form.tsx"
      to: "setOrigin/setDestination state setters"
      via: "PlaceResult from forwardGeocode triggers route computation"
      pattern: "setOrigin.*forwardGeocode"
    - from: "useForm config"
      to: "wizard step navigation"
      via: "shouldUnregister: false preserves values across step changes"
      pattern: "shouldUnregister.*false"
---

<objective>
Fix AI ride creation so that natural language input (e.g., "z Ostravy do Brna zitra v 8") pre-fills origin, destination, date, time, and price in the ride form.

Purpose: This is the most complex Phase 12 bug -- requires a forward geocoding bridge (Mapy.cz API) to convert AI-returned address strings into PlaceResult objects with coordinates, plus a react-hook-form configuration change to prevent wizard step changes from losing AI-set values.
Output: Working AI ride creation flow where all parsed fields appear in the form.
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-critical-bug-fixes-admin-setup/12-RESEARCH.md

@apps/web/app/(app)/components/ride-form.tsx
@apps/web/app/(app)/components/address-autocomplete-mapy.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add shouldUnregister:false and forwardGeocode helper to ride form</name>
  <files>apps/web/app/(app)/components/ride-form.tsx</files>
  <action>
**Step 1: Fix shouldUnregister**
Find the `useForm<CreateRide>()` call in `ride-form.tsx`. Add `shouldUnregister: false` to the options object alongside the existing `resolver` and `defaultValues`. This prevents wizard step changes from unregistering fields, so AI-set values on other steps persist.

**Step 2: Add forwardGeocode helper**
Add an `async function forwardGeocode(address: string): Promise<PlaceResult | null>` inside the component (or as a module-level function if PlaceResult type is available at module scope).

Implementation (from research Pattern 1):
```typescript
async function forwardGeocode(address: string): Promise<PlaceResult | null> {
  const MAPY_API_KEY = process.env.NEXT_PUBLIC_MAPY_CZ_API_KEY ?? "";
  const url = new URL("https://api.mapy.cz/v1/geocode");
  url.searchParams.set("apikey", MAPY_API_KEY);
  url.searchParams.set("query", address);
  url.searchParams.set("lang", "cs");
  url.searchParams.set("limit", "1");
  url.searchParams.set("type", "regional");
  url.searchParams.set("locality", "cz,sk");

  const res = await fetch(url.toString(), {
    headers: { Accept: "application/json" },
  });
  if (!res.ok) return null;

  const data = await res.json();
  const item = data?.items?.[0];
  if (!item?.position) return null;

  return {
    lat: item.position.lat,
    lng: item.position.lon,  // Mapy.cz uses "lon" not "lng" -- confirmed in address-autocomplete-mapy.tsx line 133
    address: item.name || address,
    placeId: `mapy-${item.position.lat}-${item.position.lon}`,
  };
}
```

Check the existing `PlaceResult` type/interface in the file (or imported from elsewhere). The helper must return an object matching that interface. If `PlaceResult` has additional required fields beyond `lat`, `lng`, `address`, `placeId`, populate them with sensible defaults.

**CRITICAL:** Map `position.lon` to `lng` (not `lon`). The Mapy.cz API uses `lon` but the app uses `lng`. This is confirmed by the existing pattern in `address-autocomplete-mapy.tsx`.

If `NEXT_PUBLIC_MAPY_CZ_API_KEY` is not already used in the file, verify it exists in `.env.local.example` or the environment. Per user decisions, handle either case (key present or absent -- if absent, forwardGeocode returns null and the form still works without AI geocoding, just no pre-fill).
  </action>
  <verify>
1. Read `ride-form.tsx` and confirm `shouldUnregister: false` is in the useForm options
2. Read `ride-form.tsx` and confirm `forwardGeocode` function exists with `api.mapy.cz/v1/geocode` URL and `position.lon` -> `lng` mapping
  </verify>
  <done>
`shouldUnregister: false` added to useForm config. `forwardGeocode` helper converts address strings to PlaceResult via Mapy.cz geocode API with correct lon->lng mapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update handleAiPrompt to use forwardGeocode and set all form fields</name>
  <files>apps/web/app/(app)/components/ride-form.tsx</files>
  <action>
Find the `handleAiPrompt` function (around line 252-283 per research). This function currently processes the AI response but ignores `origin_address` and `destination_address` fields.

Update `handleAiPrompt` to:

1. **Geocode origin and destination:** If the AI response contains `origin_address` (or similar field name -- inspect the actual AI response type), call `forwardGeocode(origin_address)`. If it returns a PlaceResult, call `setOrigin(result)` (or whatever setter is used elsewhere in the component for setting the origin location -- look for how the AddressAutocomplete onSelect callback works). Similarly for `destination_address` -> `forwardGeocode` -> `setDestination`.

2. **Set date/time fields:** If the AI response contains departure date/time, use `form.setValue("departureDate", ...)` and `form.setValue("departureTime", ...)` (or whatever the actual field names are in CreateRide schema). Inspect the schema to get exact field names.

3. **Set price field:** If the AI response contains a price, use `form.setValue("priceCzk", ...)` (or exact field name).

4. **Set seats:** If the AI response contains seats, use `form.setValue("seatsTotal", ...)`.

5. **Handle errors gracefully:** Wrap geocoding calls in try/catch. If geocoding fails for one address, still set the other fields that were successfully resolved. Show a toast on partial failure.

6. **Trigger route computation:** After setting both origin and destination, the component should trigger route computation. Look at how the existing origin/destination selection flow triggers `computeRoute` or similar -- the same mechanism should fire after AI-driven geocoding. If route computation depends on state updates from `setOrigin`/`setDestination`, ensure the async flow awaits state propagation or use a callback.

**Important notes:**
- Make `handleAiPrompt` async if it isn't already
- Look at the actual AI response shape (the return type from the AI server action or Edge Function call) to know exact field names
- The existing `setOrigin`/`setDestination` functions (or equivalent) likely also trigger route computation via useEffect -- confirm this by reading how manual address selection works
- Do NOT move geocoding into the AI Edge Function (per research anti-pattern) -- it must happen client-side
  </action>
  <verify>
1. Read `ride-form.tsx` and confirm `handleAiPrompt` calls `forwardGeocode` for origin/destination addresses
2. Confirm `form.setValue` is called for date, time, price, and seats fields
3. Confirm `setOrigin`/`setDestination` (or equivalent) is called with geocoded PlaceResult
4. Run `cd /Users/miakh/source/festapp-rideshare && pnpm turbo build --filter=web` to verify no build errors
  </verify>
  <done>
`handleAiPrompt` geocodes AI addresses via `forwardGeocode`, sets origin/destination via component state setters (triggering route computation), and sets date/time/price/seats via `form.setValue`. AI ride creation flow produces a fully pre-filled form.
  </done>
</task>

</tasks>

<verification>
1. `shouldUnregister: false` in useForm config
2. `forwardGeocode` function with Mapy.cz geocode API and `lon` -> `lng` mapping
3. `handleAiPrompt` geocodes both addresses and sets all form fields
4. Build passes: `pnpm turbo build --filter=web` completes without errors
</verification>

<success_criteria>
- Natural language input like "z Ostravy do Brna zitra v 8" results in origin (Ostrava), destination (Brno), date (tomorrow), time (8:00), and price pre-filled in the ride form
- Navigating between wizard steps preserves all AI-set values
- If Mapy.cz API key is missing or geocoding fails, the form still works (graceful degradation)
- No build errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-critical-bug-fixes-admin-setup/12-02-SUMMARY.md`
</output>
