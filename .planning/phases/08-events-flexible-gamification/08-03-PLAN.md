---
phase: 08-events-flexible-gamification
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00000000000034_flexible_rides.sql
  - packages/shared/src/types/database.ts
  - packages/shared/src/constants/flexible.ts
  - packages/shared/src/validation/flexible.ts
  - packages/shared/src/queries/flexible.ts
  - packages/shared/src/index.ts
  - apps/web/app/(app)/routes/page.tsx
  - apps/web/app/(app)/routes/new/page.tsx
  - apps/web/app/(app)/routes/[id]/page.tsx
  - apps/web/app/(app)/routes/[id]/route-detail.tsx
  - apps/web/app/(app)/routes/[id]/confirm-date.tsx
  - apps/web/app/(app)/components/subscribe-button.tsx
autonomous: true

must_haves:
  truths:
    - "Driver can create a route intent (flexible ride without a specific date)"
    - "Passenger can subscribe to a route intent to get notified when driver confirms a date"
    - "Driver can confirm a date for a flexible ride, converting it to a bookable ride"
    - "When driver confirms a date, all subscribers receive a push notification"
    - "Subscribers can then book a seat on the confirmed ride through normal booking flow"
  artifacts:
    - path: "supabase/migrations/00000000000034_flexible_rides.sql"
      provides: "Route intents table, subscriptions table, confirm RPC with notification trigger"
      contains: "CREATE TABLE public.route_intents"
    - path: "apps/web/app/(app)/routes/[id]/page.tsx"
      provides: "Route intent detail page with subscribe and confirm actions"
    - path: "apps/web/app/(app)/routes/new/page.tsx"
      provides: "Route intent creation form"
    - path: "packages/shared/src/validation/flexible.ts"
      provides: "Zod schemas for route intent creation and confirmation"
  key_links:
    - from: "apps/web/app/(app)/routes/[id]/confirm-date.tsx"
      to: "confirm_route_intent RPC"
      via: "supabase.rpc('confirm_route_intent')"
      pattern: "confirm_route_intent"
    - from: "confirm_route_intent RPC"
      to: "_notify() helper"
      via: "pg_net HTTP POST to send-notification for each subscriber"
      pattern: "_notify"
    - from: "apps/web/app/(app)/components/subscribe-button.tsx"
      to: "route_intent_subscriptions table"
      via: "INSERT/DELETE toggle"
      pattern: "route_intent_subscriptions"
---

<objective>
Create the flexible rides system: route intents (rides without a specific date), subscriber notifications, and date confirmation flow that converts a route intent into a bookable ride.

Purpose: Drivers who regularly travel a route but don't know their exact schedule can post a route intent. Passengers subscribe and get notified when the driver confirms a departure date, then book through the normal flow.

Output: Route intents migration, shared types/schemas/queries, route intent creation and detail pages, subscription toggle, date confirmation form with notification dispatch.
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/shared/src/index.ts
@packages/shared/src/types/database.ts
@packages/shared/src/validation/ride.ts
@packages/shared/src/constants/ride.ts
@apps/web/app/(app)/rides/new/ride-form.tsx
@supabase/migrations/00000000000031_admin_moderation.sql
@supabase/functions/send-notification/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Flexible rides database migration and shared package</name>
  <files>
    supabase/migrations/00000000000034_flexible_rides.sql
    packages/shared/src/types/database.ts
    packages/shared/src/constants/flexible.ts
    packages/shared/src/validation/flexible.ts
    packages/shared/src/queries/flexible.ts
    packages/shared/src/index.ts
  </files>
  <action>
    **Migration (00000000000034_flexible_rides.sql):**

    1. Create `route_intents` table:
       - id UUID PK DEFAULT gen_random_uuid()
       - driver_id UUID NOT NULL REFERENCES profiles(id)
       - vehicle_id UUID REFERENCES vehicles(id)
       - origin_location GEOGRAPHY(POINT, 4326) NOT NULL
       - origin_address TEXT NOT NULL
       - destination_location GEOGRAPHY(POINT, 4326) NOT NULL
       - destination_address TEXT NOT NULL
       - route_geometry GEOGRAPHY(LINESTRING, 4326)
       - route_encoded_polyline TEXT
       - seats_total INT NOT NULL DEFAULT 4 CHECK (1-8)
       - price_czk INT
       - booking_mode TEXT NOT NULL DEFAULT 'instant' CHECK IN ('instant', 'request')
       - notes TEXT
       - status TEXT NOT NULL DEFAULT 'active' CHECK IN ('active', 'confirmed', 'expired', 'cancelled')
       - confirmed_ride_id UUID REFERENCES rides(id) (set when driver confirms a date)
       - subscriber_count INT NOT NULL DEFAULT 0
       - created_at TIMESTAMPTZ DEFAULT NOW()
       - updated_at TIMESTAMPTZ DEFAULT NOW()
       - GIST indexes on origin_location and destination_location

    2. Create `route_intent_subscriptions` table:
       - id UUID PK DEFAULT gen_random_uuid()
       - route_intent_id UUID NOT NULL REFERENCES route_intents(id) ON DELETE CASCADE
       - subscriber_id UUID NOT NULL REFERENCES profiles(id)
       - created_at TIMESTAMPTZ DEFAULT NOW()
       - UNIQUE(route_intent_id, subscriber_id)

    3. RLS on route_intents:
       - SELECT: anyone can read active/confirmed intents; drivers can read own (any status)
       - INSERT: authenticated with driver_id = auth.uid()
       - UPDATE: driver can update own active intents
       - DELETE: driver can delete own active intents

    4. RLS on route_intent_subscriptions:
       - SELECT: subscriber can read own subscriptions; intent driver can see subscriber count
       - INSERT: authenticated with subscriber_id = auth.uid(), cannot subscribe to own intent
       - DELETE: subscriber can remove own subscription

    5. Trigger: increment/decrement route_intents.subscriber_count on subscription INSERT/DELETE.

    6. RPCs (all SECURITY DEFINER SET search_path = ''):
       - `confirm_route_intent(p_intent_id UUID, p_departure_time TIMESTAMPTZ, p_seats INT DEFAULT NULL, p_price INT DEFAULT NULL)`:
         - Validates caller is the intent driver
         - Locks intent row FOR UPDATE, checks status='active'
         - Creates a new ride in rides table using intent's origin/destination/route/vehicle data and the provided departure_time (and optional seats/price overrides)
         - Sets intent status='confirmed', confirmed_ride_id = new ride id
         - For each subscriber, calls _notify() with:
           - user_id: subscriber_id
           - type: 'flexible_ride_confirmed'
           - title: 'Route confirmed!'
           - body: '{driver_name} confirmed {origin} -> {destination} on {date}'
           - data: { ride_id: new_ride_id }
         - **Returns the new ride_id as UUID** (critical: the UI uses this to redirect)

       - `cancel_route_intent(p_intent_id UUID)`:
         - Validates caller is intent driver
         - Sets status='cancelled'

    7. Trigger: update updated_at on route_intents modification.

    **Shared package:**

    Constants (flexible.ts):
    - ROUTE_INTENT_STATUS: { ACTIVE: 'active', CONFIRMED: 'confirmed', EXPIRED: 'expired', CANCELLED: 'cancelled' }

    Validation (flexible.ts):
    - CreateRouteIntentSchema: { origin_address, origin_lat, origin_lng, destination_address, destination_lat, destination_lng, seats_total, price_czk?, booking_mode, notes? }
    - ConfirmRouteIntentSchema: { departure_time (ISO string, must be future), seats_total?, price_czk? }

    Database types: Add route_intents and route_intent_subscriptions table types. Add confirm_route_intent (returns UUID) and cancel_route_intent function signatures. Add RouteIntent and RouteIntentSubscription derived types.

    Queries (flexible.ts):
    - getActiveRouteIntents(client) — list active route intents with driver profile
    - getRouteIntentById(client, id) — single intent with driver profile and subscriber count
    - getMyRouteIntents(client, driverId) — driver's own intents
    - getMySubscriptions(client, userId) — user's subscribed intents
    - isSubscribed(client, intentId, userId) — check subscription status

    Index.ts: Export all new flexible ride constants, schemas, types, queries.
  </action>
  <verify>
    Run `pnpm turbo build --filter=@festapp/shared` to verify shared package compiles. Check migration SQL syntax.
  </verify>
  <done>
    Route intents and subscriptions tables exist in migration. confirm_route_intent RPC creates a ride, notifies all subscribers via _notify(), and returns the new ride_id as UUID. Shared package has flexible ride constants, Zod schemas, Database types, and query builders all exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Route intent UI pages and subscription/confirmation flows</name>
  <files>
    apps/web/app/(app)/routes/page.tsx
    apps/web/app/(app)/routes/new/page.tsx
    apps/web/app/(app)/routes/[id]/page.tsx
    apps/web/app/(app)/routes/[id]/route-detail.tsx
    apps/web/app/(app)/routes/[id]/confirm-date.tsx
    apps/web/app/(app)/components/subscribe-button.tsx
  </files>
  <action>
    **Routes browsing page (/routes):**
    - Server component fetching active route intents via getActiveRouteIntents
    - Grid of route intent cards showing driver avatar/name/rating, origin -> destination, seats, price, subscriber count
    - Link to /routes/new for drivers to create new route intents
    - Client-side search/filter by origin/destination text

    **Route intent creation page (/routes/new):**
    - react-hook-form + zodResolver(CreateRouteIntentSchema)
    - Origin and destination using AddressAutocomplete (reuse from ride creation)
    - Seats, price (optional), booking mode (instant/request), notes
    - Optionally call compute-route Edge Function for route geometry/polyline (same as ride creation) -- show route on RideMap component
    - On submit: insert into route_intents table with WKT POINT locations and optional route geometry
    - Redirect to /routes after creation
    - Only available to users (any authenticated user can create -- they become the driver for this intent)

    **Route intent detail page (/routes/[id]):**
    - Server component fetching intent by ID, checking auth for subscribe/confirm buttons
    - RouteDetail client component showing:
      - Driver profile card (avatar, name, rating) with link to /profile/[driver_id]
      - Route on map (RideMap component with polyline if available, or just origin/destination markers)
      - Origin -> Destination addresses
      - Seats, price, booking mode, notes
      - Subscriber count: "{N} people waiting"
    - SubscribeButton component (for non-driver visitors):
      - Toggle button: "Subscribe" / "Subscribed" (green check when subscribed)
      - INSERT into route_intent_subscriptions on subscribe, DELETE on unsubscribe
      - Optimistic UI with error revert
    - If viewer is the driver and intent is active:
      - "Confirm a date" button opening ConfirmDate component
    - If intent is confirmed:
      - Link to the created ride: "This route has been confirmed! View the ride"

    **ConfirmDate component (/routes/[id]/confirm-date.tsx):**
    - Client component shown on the route intent detail page for the driver
    - Form with: departure date/time (datetime-local, must be future), optional seats override, optional price override
    - react-hook-form + zodResolver(ConfirmRouteIntentSchema)
    - On submit: calls confirm_route_intent RPC via `supabase.rpc('confirm_route_intent', { ... })`
    - **On success: Extract the ride_id from the RPC response data (the RPC returns the new ride UUID). Use `router.push(\`/rides/\${rideId}\`)` to navigate to the created ride's detail page.** Show toast "Date confirmed! Subscribers have been notified." before redirect.
    - On error: show error toast, do not redirect
    - Two-step confirm pattern before final submission

    **SubscribeButton component:**
    - Reusable client component accepting intentId prop
    - Fetches current subscription status on mount via isSubscribed query
    - Handles subscribe/unsubscribe with optimistic UI
    - Shows subscriber count
    - Requires authentication (redirect to login if not authenticated)

    **Styling:** Follow existing patterns -- Tailwind, pastel design, consistent with rides pages.
  </action>
  <verify>
    Run `pnpm turbo build --filter=@festapp/web` to verify web app compiles. Verify /routes, /routes/new, /routes/[id] routes exist.
  </verify>
  <done>
    Driver can create a route intent at /routes/new. Passenger can browse intents at /routes and subscribe from /routes/[id]. Driver can confirm a date from intent detail page, which creates a ride and notifies subscribers. ConfirmDate extracts ride_id from RPC response and redirects to /rides/{rideId}. Confirmed intents link to the created ride for booking.
  </done>
</task>

</tasks>

<verification>
1. Route intents migration has valid SQL with route_intents, subscriptions tables, RLS, and RPCs
2. confirm_route_intent RPC creates a ride, returns ride_id, and dispatches notifications to all subscribers via _notify()
3. Shared package builds with flexible ride types, schemas, constants, queries
4. Web app builds with route intent pages
5. Subscribe/unsubscribe toggle works with optimistic UI
6. Date confirmation form calls RPC, extracts ride_id from response, and redirects to /rides/{rideId}
</verification>

<success_criteria>
- Driver can create a route intent (route without a date) at /routes/new
- Passenger can browse active route intents at /routes
- Passenger can subscribe/unsubscribe on route intent detail page
- Driver can confirm a date, creating a real bookable ride
- ConfirmDate redirects to /rides/{rideId} using ride_id from RPC response
- Subscribers are notified via push notification when date is confirmed
- Confirmed intent links to the created ride for normal booking flow
</success_criteria>

<output>
After completion, create `.planning/phases/08-events-flexible-gamification/08-03-SUMMARY.md`
</output>
