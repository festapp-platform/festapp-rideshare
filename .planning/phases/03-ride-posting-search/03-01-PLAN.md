---
phase: 03-ride-posting-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00000000000006_enable_postgis.sql
  - supabase/migrations/00000000000007_rides.sql
  - supabase/migrations/00000000000008_ride_waypoints.sql
  - supabase/migrations/00000000000009_recurring_patterns.sql
  - supabase/migrations/00000000000010_favorite_routes.sql
  - supabase/migrations/00000000000011_rides_rls.sql
  - supabase/migrations/00000000000012_ride_search_rpc.sql
  - supabase/migrations/00000000000013_ride_expiry_cron.sql
autonomous: true

must_haves:
  truths:
    - "PostGIS extension is enabled and geography columns work"
    - "Rides table exists with origin/destination POINT geography, route LINESTRING geography, and all ride fields"
    - "nearby_rides RPC function returns rides matching a spatial corridor query"
    - "RLS policies enforce driver-only write access and public read for active rides"
    - "Expired rides are automatically marked completed by pg_cron"
  artifacts:
    - path: "supabase/migrations/00000000000006_enable_postgis.sql"
      provides: "PostGIS extension in extensions schema"
      contains: "CREATE EXTENSION IF NOT EXISTS postgis"
    - path: "supabase/migrations/00000000000007_rides.sql"
      provides: "Rides table with geography columns and spatial indexes"
      contains: "GEOGRAPHY(POINT, 4326)"
    - path: "supabase/migrations/00000000000012_ride_search_rpc.sql"
      provides: "nearby_rides RPC function with corridor matching"
      contains: "CREATE OR REPLACE FUNCTION public.nearby_rides"
    - path: "supabase/migrations/00000000000013_ride_expiry_cron.sql"
      provides: "Scheduled ride expiry job"
      contains: "cron.schedule"
  key_links:
    - from: "supabase/migrations/00000000000007_rides.sql"
      to: "supabase/migrations/00000000000006_enable_postgis.sql"
      via: "PostGIS types depend on extension"
      pattern: "GEOGRAPHY\\(POINT"
    - from: "supabase/migrations/00000000000012_ride_search_rpc.sql"
      to: "supabase/migrations/00000000000007_rides.sql"
      via: "RPC queries rides table with ST_DWithin"
      pattern: "extensions\\.ST_DWithin"
---

<objective>
Create all database tables, indexes, RLS policies, RPC functions, and scheduled jobs for the ride posting and search system.

Purpose: Establish the entire data foundation for rides -- PostGIS geography columns enable geospatial corridor matching, RLS policies enforce access control, and the nearby_rides RPC function provides the core search capability.

Output: 8 SQL migrations pushed to remote Supabase, covering rides, waypoints, recurring patterns, favorite routes, RLS, search RPC, and ride expiry.
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ride-posting-search/03-RESEARCH.md
@.planning/phases/02-profiles-identity/02-01-SUMMARY.md
@packages/shared/src/types/database.ts
@supabase/migrations/00000000000000_initial_setup.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostGIS, rides, waypoints, recurring patterns, and favorite routes migrations</name>
  <files>
    supabase/migrations/00000000000006_enable_postgis.sql
    supabase/migrations/00000000000007_rides.sql
    supabase/migrations/00000000000008_ride_waypoints.sql
    supabase/migrations/00000000000009_recurring_patterns.sql
    supabase/migrations/00000000000010_favorite_routes.sql
  </files>
  <action>
Create 5 migration files:

**00000000000006_enable_postgis.sql:**
- `CREATE EXTENSION IF NOT EXISTS postgis SCHEMA extensions;` (MUST be `extensions` schema per Supabase -- see research Pitfall 1)

**00000000000007_rides.sql:**
- Create `public.rides` table exactly per research Pattern 1 schema:
  - `id` UUID PK with uuid_generate_v4()
  - `driver_id` UUID NOT NULL FK to profiles(id)
  - `vehicle_id` UUID FK to vehicles(id) (nullable -- driver may not have a vehicle yet)
  - `origin_location` GEOGRAPHY(POINT, 4326) NOT NULL
  - `origin_address` TEXT NOT NULL
  - `destination_location` GEOGRAPHY(POINT, 4326) NOT NULL
  - `destination_address` TEXT NOT NULL
  - `route_geometry` GEOGRAPHY(LINESTRING, 4326) (nullable -- set after route computation)
  - `route_encoded_polyline` TEXT (original encoded polyline from Google)
  - `departure_time` TIMESTAMPTZ NOT NULL
  - `seats_total` INT NOT NULL CHECK (1-8)
  - `seats_available` INT NOT NULL CHECK (0-8)
  - `suggested_price_czk` NUMERIC(10,2)
  - `price_czk` NUMERIC(10,2)
  - `distance_meters` INT
  - `duration_seconds` INT
  - `luggage_size` TEXT DEFAULT 'medium' CHECK ('none','small','medium','large')
  - `booking_mode` TEXT DEFAULT 'request' CHECK ('instant','request')
  - `preferences` JSONB DEFAULT '{}'
  - `notes` TEXT
  - `status` TEXT DEFAULT 'upcoming' CHECK ('upcoming','in_progress','completed','cancelled')
  - `recurring_pattern_id` UUID (FK added later after patterns table)
  - `created_at` TIMESTAMPTZ DEFAULT now()
  - `updated_at` TIMESTAMPTZ DEFAULT now()
- Create GIST spatial indexes: `idx_rides_origin_geo`, `idx_rides_destination_geo`, `idx_rides_route_geo`
- Create composite index `idx_rides_active_departure` on departure_time WHERE status='upcoming'
- Create index `idx_rides_driver` on (driver_id, departure_time DESC)
- Create updated_at trigger using existing `update_updated_at_column()` function from initial_setup migration

**00000000000008_ride_waypoints.sql:**
- Create `public.ride_waypoints` table:
  - `id` UUID PK
  - `ride_id` UUID NOT NULL FK to rides(id) ON DELETE CASCADE
  - `location` GEOGRAPHY(POINT, 4326) NOT NULL
  - `address` TEXT NOT NULL
  - `order_index` INT NOT NULL (position along route)
  - `type` TEXT DEFAULT 'pickup' CHECK ('pickup','dropoff')
  - `created_at` TIMESTAMPTZ DEFAULT now()
- Create GIST spatial index on location
- Create index on (ride_id, order_index)

**00000000000009_recurring_patterns.sql:**
- Create `public.recurring_ride_patterns` table exactly per research Pattern 6
- Add FK constraint from rides.recurring_pattern_id to recurring_ride_patterns(id)
- Create updated_at trigger
- Create index on (driver_id, is_active)

**00000000000010_favorite_routes.sql:**
- Create `public.favorite_routes` table exactly per research example
- UNIQUE constraint on (user_id, origin_address, destination_address)
  </action>
  <verify>
Run `supabase db push` to apply all migrations to remote Supabase. Verify no errors. Then run a quick SQL check via supabase CLI:
```bash
supabase db push
# Verify tables exist
echo "SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_name IN ('rides','ride_waypoints','recurring_ride_patterns','favorite_routes');" | supabase db remote exec
```
  </verify>
  <done>All 5 tables exist in remote Supabase with correct columns, geography types, and spatial indexes. No migration errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies, search RPC function, and ride expiry cron job</name>
  <files>
    supabase/migrations/00000000000011_rides_rls.sql
    supabase/migrations/00000000000012_ride_search_rpc.sql
    supabase/migrations/00000000000013_ride_expiry_cron.sql
  </files>
  <action>
Create 3 migration files:

**00000000000011_rides_rls.sql:**
- Enable RLS on all 4 new tables
- **rides:**
  - SELECT: authenticated users can read all rides (needed for search)
  - INSERT: authenticated users can insert rides where driver_id = auth.uid()
  - UPDATE: authenticated users can update their own rides (driver_id = auth.uid())
  - DELETE: authenticated users can delete their own rides (driver_id = auth.uid())
- **ride_waypoints:**
  - SELECT: authenticated users can read all waypoints (needed for ride detail)
  - INSERT/UPDATE/DELETE: only the driver of the parent ride (subquery: ride.driver_id = auth.uid())
- **recurring_ride_patterns:**
  - All operations: authenticated users where driver_id = auth.uid()
- **favorite_routes:**
  - All operations: authenticated users where user_id = auth.uid()

**00000000000012_ride_search_rpc.sql:**
- Create `public.nearby_rides()` function exactly per research Pattern 2
- CRITICAL: All PostGIS function calls MUST use `extensions.` prefix (ST_DWithin, ST_Distance, ST_SetSRID, ST_MakePoint)
- Use `SET search_path = ''` and LANGUAGE sql STABLE
- Parameters: origin_lat, origin_lng, dest_lat, dest_lng, search_date, radius_km DEFAULT 15, max_results DEFAULT 50
- JOIN profiles (display_name, avatar_url, rating_avg, rating_count) and LEFT JOIN vehicles (make, model, color)
- Filter: status='upcoming', seats_available > 0, departure_time within search_date to search_date + 2 days
- Corridor matching: ST_DWithin on route_geometry (with origin point fallback when route_geometry IS NULL)
- Return: ride_id, driver info, vehicle info, ride details, origin_distance_m, dest_distance_m
- ORDER BY departure_time ASC, LIMIT max_results

**00000000000013_ride_expiry_cron.sql:**
- Create `public.expire_past_rides()` function per research Pattern 5
- Use SECURITY DEFINER SET search_path = '' for the function
- Updates rides SET status='completed' WHERE status='upcoming' AND departure_time < now() - interval '6 hours'
- Schedule with pg_cron: every hour at minute 0
- Also create `public.generate_recurring_rides()` function per research Pattern 6 and schedule daily at 3 AM
  </action>
  <verify>
```bash
supabase db push
# Verify RPC function exists
echo "SELECT proname FROM pg_proc WHERE proname = 'nearby_rides';" | supabase db remote exec
# Verify cron jobs
echo "SELECT jobname, schedule FROM cron.job;" | supabase db remote exec
```
  </verify>
  <done>RLS policies protect all 4 tables. nearby_rides RPC function exists and is callable. Two cron jobs scheduled (expire-past-rides hourly, generate-recurring-rides daily).</done>
</task>

</tasks>

<verification>
- `supabase db push` completes without errors for all 8 migrations
- All 4 new tables (rides, ride_waypoints, recurring_ride_patterns, favorite_routes) exist with correct columns
- PostGIS GIST spatial indexes exist on geography columns
- RLS is enabled on all 4 tables with correct policies
- `nearby_rides` RPC function is callable
- Cron jobs for ride expiry and recurring ride generation are scheduled
</verification>

<success_criteria>
- 8 migration files created and pushed to remote Supabase
- rides table has PostGIS geography columns with GIST spatial indexes
- nearby_rides RPC function performs corridor matching via ST_DWithin on route_geometry
- RLS policies enforce driver-only write, public read for active rides
- pg_cron jobs scheduled for automatic ride expiry and recurring ride generation
</success_criteria>

<output>
After completion, create `.planning/phases/03-ride-posting-search/03-01-SUMMARY.md`
</output>
