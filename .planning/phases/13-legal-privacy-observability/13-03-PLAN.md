---
phase: 13-legal-privacy-observability
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/(app)/contexts/location-sharing-context.tsx
  - apps/web/app/(app)/components/location-sharing-banner.tsx
  - apps/web/app/(app)/layout.tsx
  - apps/web/app/(app)/hooks/use-live-location.ts
  - apps/web/lib/i18n/translations/cs.ts
  - apps/web/lib/i18n/translations/sk.ts
  - apps/web/lib/i18n/translations/en.ts
autonomous: true
requirements:
  - LEGAL-03

must_haves:
  truths:
    - "When a driver starts sharing their live location, a persistent banner appears at the top of the page"
    - "The banner is visible on ALL authenticated pages, not just the ride detail page"
    - "The banner shows who can see the driver's location (passenger names)"
    - "The banner has a stop button that stops location sharing when clicked"
    - "The banner disappears when location sharing is stopped"
    - "The banner persists across page navigation (not lost when changing routes)"
  artifacts:
    - path: "apps/web/app/(app)/contexts/location-sharing-context.tsx"
      provides: "Global location sharing state context"
      contains: "LocationSharingProvider"
    - path: "apps/web/app/(app)/components/location-sharing-banner.tsx"
      provides: "Persistent sticky banner component"
      contains: "LocationSharingBanner"
    - path: "apps/web/app/(app)/layout.tsx"
      provides: "Banner integration in app layout"
      contains: "LocationSharingBanner"
  key_links:
    - from: "apps/web/app/(app)/hooks/use-live-location.ts"
      to: "apps/web/app/(app)/contexts/location-sharing-context.tsx"
      via: "startSharing/stopSharing calls from hook into context"
      pattern: "useLocationSharing"
    - from: "apps/web/app/(app)/components/location-sharing-banner.tsx"
      to: "apps/web/app/(app)/contexts/location-sharing-context.tsx"
      via: "useLocationSharing hook consumption"
      pattern: "useLocationSharing"
    - from: "apps/web/app/(app)/layout.tsx"
      to: "apps/web/app/(app)/components/location-sharing-banner.tsx"
      via: "Component rendered in layout"
      pattern: "LocationSharingBanner"
---

<objective>
Create a global location sharing indicator visible on all authenticated pages.

Purpose: When a driver shares their live location, they must always be aware of this -- a persistent banner on every page shows who can see their location and provides a one-tap stop button. This meets the privacy disclosure requirement (LEGAL-03).

Output:
- LocationSharingContext for global state that persists across route changes
- LocationSharingBanner component (sticky, amber, with pulsing dot and stop button)
- Integration in app layout and connection to existing useLiveLocation hook
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-legal-privacy-observability/13-RESEARCH.md
@apps/web/app/(app)/layout.tsx
@apps/web/app/(app)/hooks/use-live-location.ts
@apps/web/app/(app)/components/email-confirmation-banner.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LocationSharing context and banner component</name>
  <files>apps/web/app/(app)/contexts/location-sharing-context.tsx, apps/web/app/(app)/components/location-sharing-banner.tsx, apps/web/lib/i18n/translations/cs.ts, apps/web/lib/i18n/translations/sk.ts, apps/web/lib/i18n/translations/en.ts</files>
  <action>
**1. Create `apps/web/app/(app)/contexts/location-sharing-context.tsx`:**

Create a React context following the existing i18n provider pattern (see `apps/web/lib/i18n/provider.tsx` for reference). The context must persist across route changes since it lives in the layout.

```typescript
"use client";

import { createContext, useContext, useState, useCallback } from "react";

interface LocationSharingState {
  isSharing: boolean;
  rideId: string | null;
  passengerNames: string[];
  startSharing: (rideId: string, passengerNames: string[]) => void;
  stopSharing: () => void;
  /** External stop handler set by useLiveLocation to actually stop GPS */
  registerStopHandler: (handler: () => void) => void;
}

const LocationSharingContext = createContext<LocationSharingState | null>(null);

export function LocationSharingProvider({ children }: { children: React.ReactNode }) {
  const [isSharing, setIsSharing] = useState(false);
  const [rideId, setRideId] = useState<string | null>(null);
  const [passengerNames, setPassengerNames] = useState<string[]>([]);
  const [externalStopHandler, setExternalStopHandler] = useState<(() => void) | null>(null);

  const startSharing = useCallback((rideId: string, names: string[]) => {
    setIsSharing(true);
    setRideId(rideId);
    setPassengerNames(names);
  }, []);

  const stopSharing = useCallback(() => {
    // Call the external stop handler (from useLiveLocation) to actually stop GPS
    externalStopHandler?.();
    setIsSharing(false);
    setRideId(null);
    setPassengerNames([]);
    setExternalStopHandler(null);
  }, [externalStopHandler]);

  const registerStopHandler = useCallback((handler: () => void) => {
    setExternalStopHandler(() => handler);
  }, []);

  return (
    <LocationSharingContext.Provider value={{ isSharing, rideId, passengerNames, startSharing, stopSharing, registerStopHandler }}>
      {children}
    </LocationSharingContext.Provider>
  );
}

export function useLocationSharing() {
  const ctx = useContext(LocationSharingContext);
  if (!ctx) throw new Error("useLocationSharing must be used within LocationSharingProvider");
  return ctx;
}
```

Key design decisions:
- `registerStopHandler` allows the `useLiveLocation` hook to register its `stopSharing` callback so the banner's stop button actually stops GPS tracking
- State persists in the layout-level provider, surviving route changes
- The context is intentionally simple (no external store library)

**2. Create `apps/web/app/(app)/components/location-sharing-banner.tsx`:**

Follow the pattern of existing banners (EmailConfirmationBanner, PendingRatingBanner). Render a sticky amber banner at the top when `isSharing` is true.

```typescript
"use client";

import { useLocationSharing } from "../contexts/location-sharing-context";
import { useI18n } from "@/lib/i18n/provider";

export function LocationSharingBanner() {
  const { isSharing, passengerNames, stopSharing } = useLocationSharing();
  const { t } = useI18n();

  if (!isSharing) return null;

  const names = passengerNames.length > 0
    ? passengerNames.join(", ")
    : t("location.passengers");

  return (
    <div
      role="status"
      aria-live="polite"
      className="sticky top-0 z-50 flex items-center justify-between gap-3 bg-amber-500 px-4 py-2.5 text-sm font-medium text-white shadow-md"
    >
      <div className="flex items-center gap-2">
        <span className="relative flex h-3 w-3">
          <span className="absolute inline-flex h-full w-full animate-ping rounded-full bg-white opacity-75" />
          <span className="relative inline-flex h-3 w-3 rounded-full bg-white" />
        </span>
        <span>{t("location.sharingWith").replace("{names}", names)}</span>
      </div>
      <button
        onClick={stopSharing}
        className="shrink-0 rounded-lg bg-white/20 px-3 py-1 text-xs font-bold hover:bg-white/30 focus:outline-none focus:ring-2 focus:ring-white/50"
      >
        {t("location.stop")}
      </button>
    </div>
  );
}
```

**3. Add i18n translations** to all three translation files:
- `location.sharingWith`: "Sharing location with {names}" / "Sdileni polohy s {names}" / "Zdielanie polohy s {names}"
- `location.stop`: "Stop" / "Zastavit" / "Zastavit"
- `location.passengers`: "passengers" / "spolucestujicimi" / "spolucestujucimi"

Use proper Czech/Slovak diacritics in actual implementation.
  </action>
  <verify>
1. `apps/web/app/(app)/contexts/location-sharing-context.tsx` exists with LocationSharingProvider, useLocationSharing, startSharing, stopSharing, registerStopHandler
2. `apps/web/app/(app)/components/location-sharing-banner.tsx` exists with amber sticky banner, pulsing dot, passenger names, stop button
3. i18n translations have location.sharingWith, location.stop, location.passengers keys
  </verify>
  <done>
- LocationSharingContext provides global location sharing state with start/stop/register pattern
- LocationSharingBanner renders a sticky amber bar with pulsing dot, passenger names, and stop button
- Banner only renders when isSharing is true
- i18n translations added for all three locales
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate banner into layout and connect to useLiveLocation hook</name>
  <files>apps/web/app/(app)/layout.tsx, apps/web/app/(app)/hooks/use-live-location.ts</files>
  <action>
**1. Update `apps/web/app/(app)/layout.tsx`:**

- Import `LocationSharingProvider` from `../contexts/location-sharing-context` (note: this is a client component, but it wraps children which can be server components -- this is fine, same pattern as MapProvider already used in the layout)

Actually, layout.tsx is a server component. The `LocationSharingProvider` is a client component. This works fine -- wrap it inside the existing client components. Looking at the layout, `MapProvider` is already a client component wrapping children. Add `LocationSharingProvider` as an inner wrapper.

- Import `LocationSharingBanner` from `./components/location-sharing-banner`
- Add `LocationSharingProvider` wrapping the content (inside `MapProvider`, outside the main div):
```tsx
<MapProvider>
  <LocationSharingProvider>
    <SkipLink />
    <OfflineBanner />
    <div className="flex min-h-screen flex-col bg-background md:flex-row">
      <AppNav />
      <main id="main-content" className="flex-1 pb-16 md:pb-0">
        <LocationSharingBanner />
        <EmailConfirmationBanner />
        ...
```
- Place `<LocationSharingBanner />` as the FIRST item inside `<main>`, before `EmailConfirmationBanner`. This ensures it's the topmost banner (location sharing is more urgent than email confirmation).

**2. Update `apps/web/app/(app)/hooks/use-live-location.ts`:**

The `useLiveLocation` hook manages the actual GPS sharing. It needs to communicate with the global context so the banner knows when sharing is active.

Add integration with the LocationSharing context:
- Import `useLocationSharing` from the context (with a try-catch or optional pattern since the hook might be used outside the provider in tests)
- When the driver starts sharing (inside the GPS watch success callback where `setIsSharing(true)` is called the first time), call `ctx.startSharing(rideId, [])` -- passenger names can be passed as a parameter
- When sharing stops (in the `stopSharing` callback), call `ctx.stopSharing()` -- but actually the context's `stopSharing` should call the hook's `stopSharing`, not the other way around
- **Better approach**: On mount when driver sharing is enabled, register the hook's `stopSharing` with the context via `ctx.registerStopHandler(stopSharing)`, and call `ctx.startSharing()` when GPS tracking actually starts

Modify the hook interface to accept an optional `passengerNames` prop:
```typescript
interface UseLiveLocationParams {
  rideId: string;
  isDriver: boolean;
  enabled: boolean;
  pickupLocation?: { lat: number; lng: number } | null;
  passengerNames?: string[]; // NEW: names shown in the banner
}
```

In the GPS tracking useEffect (the one that starts GPS watch), after `setIsSharing(true)` in `startWatch`:
- Use a ref to track if context was already notified
- On first position success, call context's `startSharing(rideId, passengerNames ?? [])`

Add a separate useEffect to register the stop handler:
```typescript
useEffect(() => {
  if (!isDriver || !enabled) return;
  try {
    const ctx = useLocationSharing(); // This won't work in a hook like this
  } catch { /* outside provider */ }
}, []);
```

Wait -- `useLocationSharing()` can only be called at the top level of a component/hook, not conditionally. **Better approach**: Make the context integration optional by using a try-catch pattern at the top level:

```typescript
let locationSharingCtx: ReturnType<typeof useLocationSharing> | null = null;
try {
  locationSharingCtx = useLocationSharing();
} catch {
  // Not inside LocationSharingProvider (e.g., tests)
}
```

Then in the GPS useEffect, when sharing starts:
```typescript
locationSharingCtx?.startSharing(rideId, passengerNames ?? []);
locationSharingCtx?.registerStopHandler(stopSharing);
```

And in the stopSharing callback, also notify context:
```typescript
const stopSharing = useCallback(() => {
  // ... existing cleanup code ...
  setIsSharing(false);
  locationSharingCtx?.stopSharing(); // Wait, this creates a circular call
}, []);
```

**Avoiding circular calls:** The banner's stop button calls `ctx.stopSharing()` which calls the registered `externalStopHandler` (the hook's `stopSharing`). The hook's `stopSharing` should NOT call `ctx.stopSharing()` again. Solution:

- The hook's `stopSharing` does the actual GPS cleanup + sets local `isSharing` to false
- Add a separate function to clear the context state without triggering the GPS stop
- Or: have the context's `stopSharing` call the registered handler and then clear its own state. The hook's `stopSharing` only does GPS cleanup, NOT context cleanup.

**Revised approach:**
1. The hook registers its GPS-stop function with the context via `registerStopHandler`
2. When the banner's stop button is pressed: `ctx.stopSharing()` is called, which calls the registered handler (GPS cleanup) then clears context state
3. When the hook itself stops sharing (e.g., component unmount, auto-stop): call a new method `ctx.clearSharing()` that only clears context state without calling the registered handler
4. Simplest: just have two paths. Hook's `stopSharing` clears GPS AND context. Banner's stop calls context's `stopSharing` which calls hook's stop via registered handler. To avoid double-clear, use a flag or just make `clearSharing` idempotent.

**Simplest implementation:**
- Context has `startSharing`, `stopSharing` (calls registered handler + clears state), `registerStopHandler`
- Hook's `stopSharing`: clears GPS, then sets context `isSharing = false` via a minimal `clearSharingState()` that doesn't call the handler
- Add `clearSharingState` to context that just resets state without calling handler

Actually, let's keep it really simple:
- Context has `isSharing`, `startSharing(rideId, names)`, `stopFromBanner()` (calls registered handler + clears), `clearSharing()` (just clears state)
- Hook calls `ctx.startSharing()` when GPS starts, `ctx.clearSharing()` when GPS stops naturally
- Banner calls `ctx.stopFromBanner()` which calls registered handler then `clearSharing()`
- The registered handler is the hook's raw GPS cleanup (not the hook's `stopSharing` which would re-clear context)

To keep changes minimal, just add these to the context:
- Rename the consumer-facing stop to call both the handler and clear state
- The hook clears context state directly via a separate method

After creating the context in Task 1 with this pattern, wire it up in the hook:
1. Try to get `useLocationSharing()` at the top of the hook (wrapped in try/catch for tests)
2. In `startWatch()` when first position received, call `ctx?.startSharing(rideId, passengerNames ?? [])`
3. Register the raw GPS cleanup as the stop handler: `ctx?.registerStopHandler(rawStop)` where `rawStop` clears the watch and broadcasts stop WITHOUT touching context
4. In the hook's public `stopSharing`, do raw GPS cleanup + `ctx?.clearSharing?.()`
5. On cleanup/unmount, also clear context

Add a `clearSharing` method to the context that resets state without calling the handler. Export it from useLocationSharing.
  </action>
  <verify>
1. `apps/web/app/(app)/layout.tsx` has:
   - `LocationSharingProvider` wrapping the content
   - `<LocationSharingBanner />` inside `<main>` before other banners
2. `apps/web/app/(app)/hooks/use-live-location.ts` has:
   - Optional `useLocationSharing()` at top level with try/catch
   - Calls `startSharing` when GPS tracking begins
   - Registers GPS cleanup as stop handler
   - Accepts optional `passengerNames` parameter
3. No circular call issues between hook and context
  </verify>
  <done>
- LocationSharingProvider wraps the app layout content
- LocationSharingBanner renders as first banner inside main content area
- useLiveLocation hook integrates with context: reports sharing state, registers stop handler
- Banner stop button actually stops GPS tracking via registered handler
- Banner persists across all authenticated page navigations
- LEGAL-03 requirement is fully satisfied
  </done>
</task>

</tasks>

<verification>
1. Navigate to ride detail as driver, start live location sharing -- amber banner appears
2. Navigate to a different page (e.g., /search) -- banner is still visible
3. Banner shows "Sharing location with [passenger names]" and pulsing dot
4. Click "Stop" on banner -- location sharing stops, banner disappears
5. Banner has proper accessibility (role="status", aria-live)
</verification>

<success_criteria>
- Persistent amber banner visible on all authenticated pages during location sharing
- Banner displays who can see the location
- Stop button actually terminates GPS tracking
- Banner disappears when sharing stops
- LEGAL-03 requirement fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/13-legal-privacy-observability/13-03-SUMMARY.md`
</output>
