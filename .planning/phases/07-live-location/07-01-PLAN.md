---
phase: 07-live-location
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00000000000032_live_location.sql
  - packages/shared/src/constants/location.ts
  - packages/shared/src/types/database.ts
  - packages/shared/src/index.ts
  - apps/web/app/(app)/hooks/use-live-location.ts
autonomous: true

must_haves:
  truths:
    - "start_ride RPC transitions ride from upcoming to in_progress (driver only)"
    - "Supabase Broadcast channel can send and receive location payloads"
    - "useLiveLocation hook manages Broadcast subscription and exposes driver position state"
  artifacts:
    - path: "supabase/migrations/00000000000032_live_location.sql"
      provides: "start_ride RPC for in_progress transition"
      contains: "start_ride"
    - path: "packages/shared/src/constants/location.ts"
      provides: "Location sharing constants"
      contains: "LOCATION_BROADCAST_EVENT"
    - path: "apps/web/app/(app)/hooks/use-live-location.ts"
      provides: "Broadcast hook for real-time location"
      contains: "useLiveLocation"
  key_links:
    - from: "apps/web/app/(app)/hooks/use-live-location.ts"
      to: "supabase.channel"
      via: "Broadcast subscription"
      pattern: "supabase\\.channel.*on.*broadcast"
---

<objective>
Create the foundation for live location sharing: start_ride RPC for ride state transition, shared constants/types for location payloads, and a reusable Supabase Broadcast hook (useLiveLocation) that both publishes and subscribes to driver location updates.

Purpose: Establishes the data layer and real-time transport for live location -- subsequent plans build UI on top of this hook.
Output: Migration, shared constants, Broadcast hook
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing Broadcast pattern (typing indicators in chat)
@apps/web/app/(app)/messages/components/chat-view.tsx
# Supabase client
@apps/web/lib/supabase/client.ts
# Existing ride constants
@packages/shared/src/constants/ride.ts
# Existing booking RPCs (complete_ride pattern)
@supabase/migrations/00000000000015_booking_rpcs.sql
# Shared index for exports
@packages/shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create start_ride RPC and shared location constants</name>
  <files>
    supabase/migrations/00000000000032_live_location.sql
    packages/shared/src/constants/location.ts
    packages/shared/src/types/database.ts
    packages/shared/src/index.ts
  </files>
  <action>
1. Create migration `00000000000032_live_location.sql`:
   - `start_ride(p_ride_id UUID, p_driver_id UUID)` SECURITY DEFINER RPC:
     - Validates caller is the driver (p_driver_id matches ride.driver_id)
     - Validates ride status is 'upcoming' (RAISE EXCEPTION otherwise)
     - Updates ride status to 'in_progress' and sets updated_at = now()
     - Returns void
   - Follow the same pattern as `complete_ride` in migration 00000000000015 (LANGUAGE plpgsql, SECURITY DEFINER SET search_path = '')
   - Grant EXECUTE to authenticated role

2. Create `packages/shared/src/constants/location.ts`:
   ```typescript
   /** Broadcast channel name pattern for live location. Use: `live-location-${rideId}` */
   export const LOCATION_CHANNEL_PREFIX = 'live-location-';

   /** Broadcast event name for location updates */
   export const LOCATION_BROADCAST_EVENT = 'location_update';

   /** Broadcast event name for location sharing stopped */
   export const LOCATION_STOPPED_EVENT = 'location_stopped';

   /** Location update payload type */
   export interface LocationPayload {
     lat: number;
     lng: number;
     accuracy: number;    // meters
     heading: number | null;
     speed: number | null; // m/s
     timestamp: number;   // Unix ms
   }

   /** GPS accuracy thresholds */
   export const GPS_CONFIG = {
     /** High accuracy threshold - below this we use lower frequency (meters) */
     HIGH_ACCURACY_DISTANCE: 500,
     /** Update interval when far from pickup (ms) */
     FAR_INTERVAL_MS: 10000,
     /** Update interval when near pickup (ms) */
     NEAR_INTERVAL_MS: 3000,
     /** Distance filter - minimum movement before update (meters) */
     DISTANCE_FILTER_FAR: 50,
     /** Distance filter near pickup (meters) */
     DISTANCE_FILTER_NEAR: 10,
     /** Maximum age of cached position (ms) */
     MAX_AGE_MS: 5000,
     /** Position timeout (ms) */
     TIMEOUT_MS: 15000,
   } as const;
   ```

3. Update `packages/shared/src/types/database.ts`:
   - Add `start_ride` to the Functions interface following the existing pattern (Args with p_ride_id UUID, p_driver_id UUID, Returns undefined)

4. Export from `packages/shared/src/index.ts`:
   - Add exports for LOCATION_CHANNEL_PREFIX, LOCATION_BROADCAST_EVENT, LOCATION_STOPPED_EVENT, GPS_CONFIG
   - Export type LocationPayload
  </action>
  <verify>
    Run `cd /Users/miakh/source/festapp-rideshare && pnpm turbo typecheck` -- should pass with new types/constants.
    Verify migration file exists and contains start_ride function.
  </verify>
  <done>start_ride RPC migration created, location constants and types exported from shared package, Database types updated</done>
</task>

<task type="auto">
  <name>Task 2: Create useLiveLocation Broadcast hook</name>
  <files>
    apps/web/app/(app)/hooks/use-live-location.ts
  </files>
  <action>
Create `apps/web/app/(app)/hooks/use-live-location.ts` -- a React hook that manages Supabase Broadcast for live location sharing. Follow the same Broadcast pattern used in chat-view.tsx for typing indicators.

The hook should:

1. **Accept params:** `{ rideId: string; isDriver: boolean; enabled: boolean }`

2. **State management:**
   - `driverPosition: LocationPayload | null` -- latest driver position (updated by Broadcast for passenger, by GPS for driver)
   - `isSharing: boolean` -- whether driver is actively sharing
   - `error: string | null` -- any error message

3. **Broadcast subscription (both roles):**
   - Create channel: `supabase.channel(LOCATION_CHANNEL_PREFIX + rideId)`
   - Subscribe to Broadcast event `LOCATION_BROADCAST_EVENT` -- updates `driverPosition`
   - Subscribe to Broadcast event `LOCATION_STOPPED_EVENT` -- sets `driverPosition` to null, `isSharing` to false
   - On unmount: `supabase.removeChannel(channel)` (same cleanup as chat-view.tsx)

4. **GPS tracking (driver only, when isDriver && enabled):**
   - Use `navigator.geolocation.watchPosition()` with adaptive options (use GPS_CONFIG from shared)
   - On each position update, broadcast via `channel.send({ type: 'broadcast', event: LOCATION_BROADCAST_EVENT, payload: LocationPayload })`
   - Set `isSharing = true` when watch starts

5. **Stop sharing function:**
   - `stopSharing()`: clears watchPosition, broadcasts LOCATION_STOPPED_EVENT, sets isSharing=false

6. **Return:** `{ driverPosition, isSharing, error, stopSharing }`

Mark file as `"use client"` at top. Import createClient from `@/lib/supabase/client`. Import constants from `@festapp/shared`.
  </action>
  <verify>
    Run `cd /Users/miakh/source/festapp-rideshare && pnpm turbo typecheck` -- hook should compile without errors.
    Verify the file imports from @festapp/shared and uses the Broadcast pattern.
  </verify>
  <done>useLiveLocation hook exists, subscribes to Broadcast channel, publishes GPS positions when driver, exposes driverPosition/isSharing/stopSharing</done>
</task>

</tasks>

<verification>
1. `pnpm turbo typecheck` passes
2. Migration file at supabase/migrations/00000000000032_live_location.sql contains start_ride RPC
3. packages/shared/src/constants/location.ts exports LOCATION_CHANNEL_PREFIX, LOCATION_BROADCAST_EVENT, GPS_CONFIG
4. apps/web/app/(app)/hooks/use-live-location.ts exports useLiveLocation with correct return shape
5. Shared index.ts exports all new constants and types
</verification>

<success_criteria>
- start_ride RPC exists to transition ride to in_progress
- LocationPayload type and GPS_CONFIG constants available from shared package
- useLiveLocation hook compiles and follows established Broadcast patterns
- All typecheck passes
</success_criteria>

<output>
After completion, create `.planning/phases/07-live-location/07-01-SUMMARY.md`
</output>
