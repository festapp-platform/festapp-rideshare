---
phase: 04-booking-ride-mgmt
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/web/app/(app)/components/booking-request-card.tsx
  - apps/web/app/(app)/rides/[id]/manage/page.tsx
autonomous: true

must_haves:
  truths:
    - "Driver sees a list of pending booking requests on their ride's manage page"
    - "Driver can accept a request (seats decrement, booking becomes confirmed)"
    - "Driver can reject a request (booking cancelled with 'rejected by driver' reason)"
    - "Accepted/rejected requests update in real-time via Supabase Realtime subscription"
    - "Manage page is only accessible to the ride's driver"
  artifacts:
    - path: "apps/web/app/(app)/components/booking-request-card.tsx"
      provides: "Card component showing pending request with accept/reject actions"
    - path: "apps/web/app/(app)/rides/[id]/manage/page.tsx"
      provides: "Driver's ride management page with request handling"
  key_links:
    - from: "apps/web/app/(app)/components/booking-request-card.tsx"
      to: "supabase RPC respond_to_booking"
      via: "supabase.rpc('respond_to_booking', {...})"
      pattern: "rpc\\('respond_to_booking'"
    - from: "apps/web/app/(app)/rides/[id]/manage/page.tsx"
      to: "packages/shared/src/queries/bookings.ts"
      via: "getBookingsForRide query"
      pattern: "getBookingsForRide"
---

<objective>
Build the request-and-approve booking flow where drivers can manage pending seat requests.

Purpose: Some drivers prefer to approve passengers before confirming seats. This plan creates the driver's management view for accepting/rejecting requests, with real-time updates so drivers see new requests without refreshing.

Output: BookingRequestCard component with accept/reject actions, ride manage page at /rides/[id]/manage.
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-booking-ride-mgmt/04-RESEARCH.md
@.planning/phases/04-booking-ride-mgmt/04-01-SUMMARY.md
@apps/web/app/(app)/components/ride-detail.tsx
@packages/shared/src/queries/bookings.ts
@packages/shared/src/constants/booking.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BookingRequestCard component with accept/reject actions</name>
  <files>apps/web/app/(app)/components/booking-request-card.tsx</files>
  <action>
'use client' component receiving: `booking` (with joined passenger profile: id, display_name, avatar_url, rating_avg, seats_booked, status, created_at), `onRespond` callback.

Layout:
- Card with passenger avatar (or initials fallback), display_name (linked to /profile/{id}), rating stars if available
- "Requested {n} seat(s)" text with relative time (date-fns formatDistanceToNow)
- Two action buttons: "Accept" (green/primary) and "Reject" (red/destructive)
- Loading state: disable both buttons, show spinner on the clicked one
- After action: button text updates to "Accepted" or "Rejected" with fade animation via CSS transition

On Accept click:
```typescript
const { error } = await supabase.rpc('respond_to_booking', {
  p_booking_id: booking.id,
  p_driver_id: currentUserId,
  p_accept: true,
});
```
- On success: toast "Booking accepted", call onRespond callback
- On error "Not enough seats": toast "Not enough seats available to accept this request"
- On error other: toast "Failed to accept booking"

On Reject click:
```typescript
const { error } = await supabase.rpc('respond_to_booking', {
  p_booking_id: booking.id,
  p_driver_id: currentUserId,
  p_accept: false,
});
```
- On success: toast "Request rejected", call onRespond callback
- On error: toast "Failed to reject request"

Use createBrowserClient for Supabase. Use pastel design tokens for card styling.
  </action>
  <verify>`pnpm turbo build --filter=web` compiles without errors.</verify>
  <done>BookingRequestCard renders passenger info with accept/reject buttons, handles RPC calls with loading states and error messages.</done>
</task>

<task type="auto">
  <name>Task 2: Create ride manage page with request list and Realtime subscription</name>
  <files>
    apps/web/app/(app)/rides/[id]/manage/page.tsx
    apps/web/app/(app)/components/ride-detail.tsx
  </files>
  <action>
**Ride manage page** (`rides/[id]/manage/page.tsx`):

Server component that:
1. Fetches ride data and verifies current user is the driver (redirect to /rides/[id] if not)
2. Fetches all bookings for this ride via getBookingsForRide
3. Renders a client component ManageRideContent

ManageRideContent client component (can be in same file or separate):
- Shows ride summary header (origin -> destination, date, seats status)
- **Pending Requests section:** Filter bookings with status='pending', render each with BookingRequestCard
  - If no pending: show "No pending requests" empty state
- **Confirmed Passengers section:** Filter bookings with status='confirmed', show passenger list (reuse or similar to PassengerList from 04-02)
  - Show total confirmed seats vs seats_total
- **Realtime subscription:** Subscribe to Supabase Realtime Postgres Changes on the bookings table filtered by ride_id:
  ```typescript
  supabase.channel(`ride-bookings-${rideId}`)
    .on('postgres_changes', {
      event: '*',
      schema: 'public',
      table: 'bookings',
      filter: `ride_id=eq.${rideId}`,
    }, (payload) => {
      // Refresh bookings list on any change
      router.refresh();
    })
    .subscribe();
  ```
  - Clean up subscription on unmount
  - This ensures driver sees new requests without refreshing
- onRespond callback from BookingRequestCard: trigger router.refresh()

**Update ride-detail.tsx:**
- For the ride owner (when currentUserId === driverId), add a "Manage Bookings" link/button that navigates to `/rides/${rideId}/manage`
- Show this button near the existing edit/cancel owner actions, only when ride has booking_mode='request' OR has any pending bookings
- Also show a badge with pending request count if > 0 (e.g., "3 pending requests")
  </action>
  <verify>
1. `pnpm turbo build --filter=web` compiles
2. Navigate to /rides/[id]/manage as the ride driver: page loads with bookings
3. Non-driver accessing /rides/[id]/manage redirects to /rides/[id]
4. Accept a pending request: booking moves to confirmed section, seats update
5. Reject a pending request: booking disappears from pending list
  </verify>
  <done>Ride manage page shows pending requests and confirmed passengers with real-time updates. Driver can accept/reject requests. Ride detail shows "Manage Bookings" link for drivers with pending count badge.</done>
</task>

</tasks>

<verification>
1. Request-mode ride: passenger clicks "Request seat", request appears in driver's manage view
2. Driver accepts: booking confirmed, seats decremented, passenger sees "Booked" on ride detail
3. Driver rejects: booking cancelled with reason, passenger sees booking cleared
4. Real-time: new request appears on manage page without page refresh
5. Non-driver cannot access manage page (redirected)
6. "Manage Bookings" link visible to driver on ride detail with pending count
</verification>

<success_criteria>
- Request-and-approve flow works end-to-end: request -> driver sees -> accept/reject -> outcome visible
- Supabase Realtime subscription delivers new booking events to driver's manage page
- Accept correctly decrements seats, reject does not affect seat count
- Error handling covers seats exhaustion during accept
</success_criteria>

<output>
After completion, create `.planning/phases/04-booking-ride-mgmt/04-03-SUMMARY.md`
</output>
