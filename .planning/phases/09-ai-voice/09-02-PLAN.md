---
phase: 09-ai-voice
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp-server/package.json
  - packages/mcp-server/tsconfig.json
  - packages/mcp-server/src/index.ts
  - packages/mcp-server/src/tools.ts
  - packages/mcp-server/src/auth.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "MCP server starts and registers ride operation tools via stdio transport"
    - "External AI assistants can list available tools (ride posting, search, booking, management)"
    - "MCP tools execute authenticated Supabase RPCs using user's JWT token"
    - "MCP server validates inputs and returns structured results"
  artifacts:
    - path: "packages/mcp-server/src/index.ts"
      provides: "MCP server entry point with stdio transport"
      contains: "StdioServerTransport"
    - path: "packages/mcp-server/src/tools.ts"
      provides: "Tool definitions and handlers for all ride operations"
      contains: "create_ride"
    - path: "packages/mcp-server/src/auth.ts"
      provides: "Supabase auth helper for MCP context"
      contains: "createClient"
    - path: "packages/mcp-server/package.json"
      provides: "MCP server package with dependencies"
      contains: "@modelcontextprotocol/sdk"
  key_links:
    - from: "packages/mcp-server/src/tools.ts"
      to: "packages/mcp-server/src/auth.ts"
      via: "authenticated Supabase client for RPC calls"
      pattern: "getSupabaseClient"
    - from: "packages/mcp-server/src/index.ts"
      to: "@modelcontextprotocol/sdk"
      via: "MCP Server and StdioServerTransport"
      pattern: "new Server"
---

<objective>
Standalone MCP server exposing ride operations as tools for external AI assistants (Claude Desktop, ChatGPT, etc.).

Purpose: Enables external AI assistants to operate the rideshare app on behalf of authenticated users. The MCP server uses stdio transport and authenticates via Supabase JWT passed as environment config.

Output: `packages/mcp-server` package with MCP server, tool definitions, and auth helper
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/shared/src/constants/ride.ts
@packages/shared/src/constants/booking.ts
@packages/shared/src/validation/ride.ts
@packages/shared/src/validation/booking.ts
@supabase/functions/_shared/supabase-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP server package setup and auth helper</name>
  <files>
    packages/mcp-server/package.json
    packages/mcp-server/tsconfig.json
    packages/mcp-server/src/auth.ts
    packages/mcp-server/src/index.ts
  </files>
  <action>
Create `packages/mcp-server/package.json`:
```json
{
  "name": "@festapp/mcp-server",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "bin": { "festapp-rideshare-mcp": "./dist/index.js" },
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "tsx src/index.ts"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.12.1",
    "@supabase/supabase-js": "^2.95.3",
    "zod": "^3.25.0"
  },
  "devDependencies": {
    "tsx": "^4.19.0",
    "typescript": "^5.7.0"
  }
}
```

Create `packages/mcp-server/tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "declaration": true
  },
  "include": ["src"]
}
```

Create `packages/mcp-server/src/auth.ts`:
- Export `getSupabaseClient(supabaseUrl: string, supabaseKey: string, userJwt?: string)` that creates a Supabase client. If `userJwt` is provided, set Authorization header to `Bearer ${userJwt}` for RLS-scoped access. Otherwise use service_role key.
- Read config from environment: `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`, `SUPABASE_USER_JWT` (optional)
- Export `getAuthenticatedClient()` convenience function that reads env vars and calls getSupabaseClient

Create `packages/mcp-server/src/index.ts`:
- Import `{ Server }` from `@modelcontextprotocol/sdk/server/index.js`
- Import `{ StdioServerTransport }` from `@modelcontextprotocol/sdk/server/stdio.js`
- Create server with name "festapp-rideshare" and version "0.1.0"
- Register tool handlers via `registerTools(server)` (imported from tools.ts, created in Task 2)
- Connect via StdioServerTransport
- Add shebang `#!/usr/bin/env node` at top for bin execution
- Log startup to stderr (not stdout, as stdout is for MCP protocol)

Run `cd packages/mcp-server && pnpm install` to install dependencies.
  </action>
  <verify>Run `cd /Users/miakh/source/festapp-rideshare/packages/mcp-server && pnpm build` — TypeScript compiles without errors (tools.ts can be a stub initially).</verify>
  <done>MCP server package exists with package.json, tsconfig, auth helper, and index.ts entry point that starts a stdio MCP server.</done>
</task>

<task type="auto">
  <name>Task 2: MCP tool definitions and handlers for ride operations</name>
  <files>
    packages/mcp-server/src/tools.ts
  </files>
  <action>
Create `packages/mcp-server/src/tools.ts`:

Export `registerTools(server: Server)` function that registers:

1. **list_tools handler** — Returns tool definitions for:
   - `create_ride`: inputSchema with origin_address, destination_address, departure_date (ISO), departure_time (HH:MM), available_seats (1-8), price_per_seat (optional number), notes (optional string). Description: "Create a new ride offering."
   - `search_rides`: inputSchema with origin_address, destination_address, date (optional ISO), radius_km (optional, default 10). Description: "Search for available rides near a route."
   - `book_seat`: inputSchema with ride_id (UUID), seats (1-4, default 1). Description: "Book seat(s) on a ride."
   - `cancel_booking`: inputSchema with booking_id (UUID), reason (optional). Description: "Cancel an existing booking."
   - `edit_ride`: inputSchema with ride_id (UUID) + optional fields from create_ride. Description: "Edit an existing ride."
   - `complete_ride`: inputSchema with ride_id (UUID). Description: "Mark a ride as completed."
   - `my_rides`: inputSchema with status (optional: upcoming/past). Description: "List your rides as driver or passenger."
   - `my_bookings`: inputSchema with status (optional: upcoming/past). Description: "List your bookings."

2. **call_tool handler** — Switch on tool name:
   - `create_ride`: Call Supabase RPC or direct insert. Build ride data from params, call `supabase.from('rides').insert(...)`. Return created ride data.
   - `search_rides`: Call `supabase.rpc('nearby_rides', { ... })` with origin/destination coordinates. Since MCP doesn't have geocoding, accept addresses and note that coordinate resolution would need the compute-route Edge Function. For now, do a simpler text-based search: `supabase.from('rides').select('*').ilike('origin_address', '%${origin}%').ilike('destination_address', '%${dest}%')`.
   - `book_seat`: Call `supabase.rpc('book_seat', { p_ride_id, p_seats })`.
   - `cancel_booking`: Call `supabase.rpc('cancel_booking', { p_booking_id, p_reason })`.
   - `edit_ride`: Call `supabase.from('rides').update(...)`.eq('id', ride_id)`.
   - `complete_ride`: Call `supabase.rpc('complete_ride', { p_ride_id })`.
   - `my_rides`: Query rides where driver_id = user or bookings where passenger_id = user.
   - `my_bookings`: Query bookings for current user.

Each handler:
- Gets authenticated Supabase client via `getAuthenticatedClient()`
- Validates required params (return error text if missing)
- Executes Supabase query
- Returns `{ content: [{ type: "text", text: JSON.stringify(result, null, 2) }] }` on success
- Returns `{ content: [{ type: "text", text: error_message }], isError: true }` on failure

Import Zod for input validation. Use inline schemas (don't import from shared — MCP server is standalone Node.js).
  </action>
  <verify>Run `cd /Users/miakh/source/festapp-rideshare/packages/mcp-server && pnpm build` — compiles. Then `echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | SUPABASE_URL=http://localhost:54321 SUPABASE_SERVICE_ROLE_KEY=test node dist/index.js` should output tool definitions (may fail on actual Supabase call but tool listing should work).</verify>
  <done>MCP server exposes 8 ride operation tools with proper input schemas. Tools execute authenticated Supabase queries and return structured results. `pnpm build` compiles successfully.</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds in packages/mcp-server
2. MCP server starts and responds to tools/list with 8 tool definitions
3. Tool input schemas match ride operation parameters
4. Auth helper creates properly scoped Supabase clients
</verification>

<success_criteria>
- MCP server package exists at packages/mcp-server with proper package.json and tsconfig
- Server starts via stdio transport and registers tools for all ride operations
- Tools use authenticated Supabase client to execute RPCs
- External AI assistants can discover and invoke tools via MCP protocol
</success_criteria>

<output>
After completion, create `.planning/phases/09-ai-voice/09-02-SUMMARY.md`
</output>
