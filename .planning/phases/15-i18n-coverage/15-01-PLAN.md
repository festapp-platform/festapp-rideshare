---
phase: 15-i18n-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/lib/i18n/provider.tsx
  - apps/web/lib/i18n/translations.ts
  - apps/web/app/(app)/components/ride-detail.tsx
  - apps/web/app/(app)/my-rides/page.tsx
  - apps/web/app/(app)/components/booking-button.tsx
autonomous: true
requirements: [I18N-01, I18N-02]

must_haves:
  truths:
    - "t('key', { name: 'Jan' }) interpolates variables into the translated string"
    - "Existing callers with {placeholder} translation values now pass vars argument and render correctly"
    - "Ride detail page shows all UI text in the selected locale (cs/sk/en)"
    - "My Rides page shows all UI text in the selected locale"
    - "Booking button shows all UI text in the selected locale"
  artifacts:
    - path: "apps/web/lib/i18n/provider.tsx"
      provides: "t() with optional vars parameter for interpolation"
      contains: "vars?: Record<string, string | number>"
    - path: "apps/web/lib/i18n/translations.ts"
      provides: "New translation keys for rideDetail, myRides, bookingButton namespaces"
      contains: "rideDetail."
    - path: "apps/web/app/(app)/components/ride-detail.tsx"
      provides: "Fully translated ride detail component"
      contains: "useI18n"
    - path: "apps/web/app/(app)/my-rides/page.tsx"
      provides: "Fully translated my rides page"
      contains: "useI18n"
    - path: "apps/web/app/(app)/components/booking-button.tsx"
      provides: "Fully translated booking button"
      contains: "useI18n"
  key_links:
    - from: "apps/web/lib/i18n/provider.tsx"
      to: "apps/web/lib/i18n/translations.ts"
      via: "t() reads from translations[locale]"
      pattern: "translations\\[locale\\]"
    - from: "apps/web/app/(app)/components/ride-detail.tsx"
      to: "apps/web/lib/i18n/provider.tsx"
      via: "useI18n() hook"
      pattern: "useI18n"
---

<objective>
Add variable interpolation to the i18n t() function and translate the three largest core flow components (ride-detail, my-rides, booking-button) to all three locales.

Purpose: Enables dynamic content in translations (names, counts, prices) and covers the highest-traffic pages in the app.
Output: Working interpolation in t(), ~65 new translation keys, 3 fully translated core components.
</objective>

<execution_context>
@/Users/miakh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/miakh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-i18n-coverage/15-RESEARCH.md
@apps/web/lib/i18n/provider.tsx
@apps/web/lib/i18n/translations.ts
@apps/web/app/(app)/components/ride-detail.tsx
@apps/web/app/(app)/my-rides/page.tsx
@apps/web/app/(app)/components/booking-button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add interpolation to t() and fix existing callers</name>
  <files>
    apps/web/lib/i18n/provider.tsx
    apps/web/lib/i18n/translations.ts
  </files>
  <action>
1. Update the `t()` callback in `provider.tsx` to accept an optional `vars` parameter:
   ```typescript
   const t = useCallback(
     (key: string, vars?: Record<string, string | number>): string => {
       const dict = translations[locale];
       let value = (dict as Record<string, string>)[key] ?? key;
       if (vars) {
         for (const [k, v] of Object.entries(vars)) {
           value = value.replace(new RegExp(`\\{${k}\\}`, 'g'), String(v));
         }
       }
       return value;
     },
     [locale],
   );
   ```

2. Update the `I18nContextValue` type to match:
   ```typescript
   t: (key: string, vars?: Record<string, string | number>) => string;
   ```

3. Audit all existing translation keys in translations.ts that contain `{...}` placeholders. Search for patterns like `{length}`, `{names}`, `{price}`, `{currency}`, `{count}`, `{name}` in the cs/sk/en dictionaries.

4. Find all callers of those keys across the codebase (grep for the key names) and update them to pass the vars argument. Key files to check: login page (auth.otpSent), ride-form (rideForm.recommended), location-sharing-banner (location.sharingWith), any other files using keys with placeholders.

5. Verify no `{placeholder}` text renders literally in the app by searching for unresolved placeholder patterns.
  </action>
  <verify>
Run `npx tsc --noEmit` from apps/web to confirm type checking passes. Grep translations.ts for `{` patterns and verify every matching key has callers passing vars.
  </verify>
  <done>t() accepts optional vars parameter, I18nContextValue type updated, all existing callers with placeholder keys pass the vars argument correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Translate ride-detail, my-rides, and booking-button components</name>
  <files>
    apps/web/app/(app)/components/ride-detail.tsx
    apps/web/app/(app)/my-rides/page.tsx
    apps/web/app/(app)/components/booking-button.tsx
    apps/web/lib/i18n/translations.ts
  </files>
  <action>
For each of the three components, follow this pattern:

1. **ride-detail.tsx** (~40 strings):
   - Add `import { useI18n } from "@/lib/i18n/provider";` (or use existing import path)
   - Add `const { t } = useI18n();` at top of component
   - Replace ALL hardcoded English strings with t() calls using `rideDetail.*` namespace
   - Key strings to translate: "Trip Details", "Distance", "Duration", "Price", "Driver", "Vehicle", "Preferences", "Seats available", "Manage Bookings", "Live Location", "Share My Location", "Stop Sharing", "Complete Ride", "Edit Ride", "Cancel Ride", "Cancel Booking", "Rate this ride", all toast messages, section headers, labels, button text
   - For strings with dynamic values (e.g., "3 seats available"), use interpolation: `t('rideDetail.seatsAvailable', { count: seats })`
   - Do NOT translate user-generated content (names, addresses, notes)

2. **my-rides/page.tsx** (~25 strings):
   - Add useI18n import and hook call
   - Replace hardcoded strings with t() calls using `myRides.*` namespace
   - Key strings: "My Rides", "As Driver", "As Passenger", "Upcoming", "Past", "No upcoming rides", "Post a ride", "seats", "Cancel Booking", "Search for a Ride", empty state messages, tab labels
   - Use interpolation for dynamic counts

3. **booking-button.tsx** (~12 strings):
   - Add useI18n import and hook call
   - Replace hardcoded strings with t() calls using `booking.*` namespace (extend existing namespace if it exists, or use `bookingButton.*`)
   - Key strings: "Request pending", "Booked", "Fully booked", "Seats", "Book N seat(s)", "Request N seat(s)", "Processing", error toast messages
   - Use interpolation for seat count

4. **translations.ts**: Add ALL new keys to:
   - The `TranslationKeys` type definition
   - The `cs` dictionary (Czech - primary)
   - The `sk` dictionary (Slovak - machine translate from Czech, keep natural)
   - The `en` dictionary (English)

**Czech translations:** Write natural Czech. Use informal "ty" form consistent with existing translations.
**Slovak translations:** Machine translate from Czech. Slovak and Czech are similar but not identical -- use proper Slovak vocabulary (e.g., "Jazda" not "Jizda", "Vodicka" not "Ridic").
**English translations:** Natural, concise English.

Ensure the TranslationKeys type has entries for every new key, and all three dictionaries have values for every key.
  </action>
  <verify>
Run `npx tsc --noEmit` from apps/web to confirm no TypeScript errors (missing keys will cause type errors since dictionaries are typed as TranslationKeys). Grep ride-detail.tsx, my-rides/page.tsx, and booking-button.tsx for remaining hardcoded English strings (look for quoted text inside JSX that isn't a className, href, or variable).
  </verify>
  <done>ride-detail.tsx, my-rides/page.tsx, and booking-button.tsx use t() for all user-facing strings. TranslationKeys type and all three locale dictionaries include ~65 new keys with no TypeScript errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in apps/web (TypeScript catches missing translation keys)
2. No hardcoded English strings remain in the three translated components (grep for quoted strings in JSX)
3. t('key', { var: value }) correctly interpolates variables
4. Existing callers with placeholder keys render dynamic values instead of literal `{placeholder}`
</verification>

<success_criteria>
- t() function supports string interpolation with optional vars parameter
- ride-detail.tsx fully translated (~40 keys in cs/sk/en)
- my-rides/page.tsx fully translated (~25 keys in cs/sk/en)
- booking-button.tsx fully translated (~12 keys in cs/sk/en)
- All existing placeholder callers updated to pass vars
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/15-i18n-coverage/15-01-SUMMARY.md`
</output>
